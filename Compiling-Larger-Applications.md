Most example compilations in the z88dk documentation and examples are single line examples which can be copy/pasted to generate the same result.

For smaller applications where all code is located in a single file, this is the easiest way of compiling, however for larger applications, especially those compiled with zsdcc, this can result in a long code-compile-run development cycle which isn't very productive.

### Pragma support

When a source file is processed, the pragmas are parsed and written out to the `zcc_opt.def` file. Unfortunately this file is cleaned on each invocation of zcc so using our makefile above will cause the pragmas to be in used at the linking stage.

zcc supports the `-pragma-include=` option which should be used to specify a file which contains all pragma directives needed by your application. 

### Output binary name

The output name specified with the `-o` option at the linking stage is the name of the file that is to be produced by the linker, not that generated by the `appmake` tool.

## Compiling for many targets (classic)

Many z88dk projects (especially those that use classic) aim to write portable code that can be run on many targets. If we assume a project with the following structure:

```
main.c
file.c
zx/extra.c
zx/zpragma.inc
multi8/extra.c
```

For speed of compilation, it's best to use a tool that can track modified files and only build what has changed. Both the easiest and hardest way to achieve this is using a `Makefile` so to make life simpler, a usable makefile is located within `{z88dk}/support/multitarget_build`. This makefile has only 3 values that need to be modified:

```makefile
# Targets that you want to compile for
TARGETS ?= zx multi8

# Name of the output binary
APPNAME := program.bin

# Source files shared between all z88dk targets
COMMON_SRCS := $(wildcard *.c) $(wildcard *.asm)
```

Typically, you probably only need to change `TARGETS` and `APPNAME` if desired.

To build for all of your selected targets just type `make`. To print out the commands as they are running  then enter `make Q=`. If you wish to just build for a particular target then enter`make zx` or `make multi8` for example.

The following files are created in `build/`when make is invoked:

```
build//zx/main.o
build//zx/zx/extra.o
build//zx/program.map
build//zx/program_BANK_7.bin
build//zx/program.bin
build//zx/func.o
build//zx/program.tap
build//multi8/main.o
build//multi8/program.map
build//multi8/program.bin
build//multi8/program.cas
build//multi8/func.o
build//multi8/multi8/extra.o
```

### Advanced Tuning

Despite the best intentions, it's almost inevitable that extra options will need to be supplied at the compiler or linking stages. 

For `#define` values, if we example the compilation line given for a .c files:

```shell
zcc +zx  -Izx -o build/zx/func.o -c func.c
```

Then we can see that the local target/ directory (in this case) `zx` is added to the include search path. Thus we can easily create a file named, say, `defines.h`, include a copy in each target directory and `#include` it.

Alternatively, and at the risk of complicating the makefile, any compilation flags can be supplied using makefile variables (where `{target}` is replaced by the appropriate target).

```makefile
CFLAGS_{target} = 
LDFLAGS_{target} =
```


